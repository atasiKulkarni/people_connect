import { createSlice } from '@reduxjs/toolkit';
import type { PayloadAction } from '@reduxjs/toolkit'; // Use 'type' keyword for import
import type { RootState } from "../../../redux/store.ts"; 
import type { EngagePost, EngageState, LikedState, SaveState } from '../model/EnagageModel.ts';
import { createPost, getMyActivity, getPost, getSavedPost, toggleLike, toggleSave } from '../action/EnagageAction.ts';

export type Status = 'idle' | 'loading' | 'succeeded' | 'failed';

// Define the initial state with the correct types
const initialState: EngageState = {
  items: [],
  status: 'idle',
  error: null,
};

export const engageSlice = createSlice({
  name: 'engage',
  initialState,
  reducers: {
    // Synchronous reducers go here if needed
  },
  // Extra reducers handle actions generated by createAsyncThunk
  extraReducers: (builder) => {
    builder

    // getPost cases
      .addCase(getPost.pending, (state) => {
        console.log("fetch engage pending...");
        state.status = 'loading';
      })
      .addCase(getPost.fulfilled, (state, action: PayloadAction<EngagePost[]>) => {
        console.log("fetch engage fulfilled...");
        state.status = 'succeeded';
        // Type of action.payload is automatically inferred as engage[] here
        state.items = action.payload; 
      })
      .addCase(getPost.rejected, (state, action) => {
        console.log("fetch engage rejected...");
        state.status = 'failed';
        state.error = action.error.message || 'Something went wrong'; // Ensure error is a string
      })

    // createPost cases

    .addCase(createPost.pending, (state) => {
      console.log("fetch engage pending...");
      state.status = 'loading';
    })
    .addCase(createPost.fulfilled, (state, action: PayloadAction<EngagePost>) => {
      console.log("fetch engage fulfilled...");
      state.status = 'succeeded';
      
      // Type of action.payload is automatically inferred as engage[] here
      if (Array.isArray(action.payload)) {
        state.items = action.payload; 
      } else {
        // 2. Add the new post to the front of the list (unshift) 
        // or end of the list (push)
        state.items.unshift(action.payload); 
      }
    })
    .addCase(createPost.rejected, (state, action) => {
      console.log("fetch engage rejected...");
      state.status = 'failed';
      state.error = action.error.message || 'Something went wrong'; // Ensure error is a string
    })


     // toggle like
     .addCase(toggleLike.pending, (state) => {
      console.log("fetch toggle like pending...");
      state.status = 'loading';
    })
    .addCase(toggleLike.fulfilled, (state, action: PayloadAction<LikedState>) => {
      const { post_id, liked } = action.payload;
      
      const existingPost = state.items.find((item) => item.id === post_id);
      
      if (existingPost) {
        existingPost.is_liked = liked;  
      }
      state.status = 'succeeded';
    })
    .addCase(toggleLike.rejected, (state, action) => {
      console.log("fetch toggle like rejected...");
      state.status = 'failed';
      state.error = action.error.message || 'Something went wrong'; // Ensure error is a string
    })

    // myactivity
    .addCase(getMyActivity.pending, (state) => {
      console.log("fetch my_activty pending...");
      state.status = 'loading';
    })
    .addCase(getMyActivity.fulfilled, (state, action: PayloadAction<EngagePost[]>) => {
      console.log("fetch my_activity fulfilled...");
      state.status = 'succeeded';
      state.items = action.payload; 
    })
    .addCase(getMyActivity.rejected, (state, action) => {
      console.log("fetch my_activity rejected...");
      state.status = 'failed';
      state.error = action.error.message || 'Something went wrong'; // Ensure error is a string
    })

        // toggle save
        .addCase(toggleSave.pending, (state) => {
          console.log("fetch toggle save pending...");
          state.status = 'loading';
        })
        .addCase(toggleSave.fulfilled, (state, action: PayloadAction<SaveState>) => {
          const { post_id, saved } = action.payload;
          
          const existingPost = state.items.find((item) => item.id === post_id);
          
          if (existingPost) {
            existingPost.is_liked = saved;  
          }
          state.status = 'succeeded';
        })
        .addCase(toggleSave.rejected, (state, action) => {
          console.log("fetch toggle save rejected...");
          state.status = 'failed';
          state.error = action.error.message || 'Something went wrong'; // Ensure error is a string
        })
    
        // mySavedPost
        .addCase(getSavedPost.pending, (state) => {
          console.log("fetch my_SavedPost pending...");
          state.status = 'loading';
        })
        .addCase(getSavedPost.fulfilled, (state, action: PayloadAction<EngagePost[]>) => {
          console.log("fetch my_SavedPost fulfilled...");
          state.status = 'succeeded';
          state.items = action.payload; 
        })
        .addCase(getSavedPost.rejected, (state, action) => {
          console.log("fetch my_SavedPost rejected...");
          state.status = 'failed';
          state.error = action.error.message || 'Something went wrong'; // Ensure error is a string
        })

  },
});

// Export selectors (functions to access parts of the state)
// Use the RootState type if you have it defined
export const selectEngage = (state: RootState) => state.engage.items;
export const selectEngageStatus = (state: RootState) => state.engage.status;
export const selectEngageError = (state: RootState) => state.engage.error;

// Export the reducer
export default engageSlice.reducer;
